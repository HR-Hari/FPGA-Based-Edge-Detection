`timescale 1ns / 1ps

module tb_Sobel;

    // Parameters for a small test image
    parameter WIDTH = 128;
    parameter HEIGHT = 128;
    parameter IMAGE_SIZE = WIDTH * HEIGHT;

    // Inputs to the DUT (Device Under Test)
    reg clk;
    reg rst;
    reg [7:0] p11, p12, p13;
    reg [7:0] p21, p22, p23;
    reg [7:0] p31, p32, p33;

    // Output from the DUT
    wire [7:0] pixel_out;

    // Memories for file I/O
    reg [7:0] image_in [0:IMAGE_SIZE-1];
    integer file_out;
    integer r, c;

    // Instantiate the Sobel Core
    Sobel uut (
        .clk(clk),
        .rst(rst),
        .p11(p11), .p12(p12), .p13(p13),
        .p21(p21), .p22(p22), .p23(p23),
        .p31(p31), .p32(p32), .p33(p33),
        .pixel_out(pixel_out)
    );

    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk; // 10ns period (100MHz)
    end

    // Test sequence
    initial begin
        // 1. Initialize and open files
        rst = 1;
        p11=0; p12=0; p13=0;
        p21=0; p22=0; p23=0;
        p31=0; p32=0; p33=0;
        
        // Load the hex text file generated by Python
        $readmemh("input_image.hex", image_in);
        file_out = $fopen("output_image.hex", "w");

        #20;
        rst = 0;
        #20;

        // 2. Iterate through the image (leaving a 1-pixel border for the 3x3 window)
        for (r = 1; r < HEIGHT - 1; r = r + 1) begin
            for (c = 1; c < WIDTH - 1; c = c + 1) begin
                
                // Feed the 3x3 window at the rising edge
                @(posedge clk);
                p11 <= image_in[(r-1)*WIDTH + (c-1)];
                p12 <= image_in[(r-1)*WIDTH + c];
                p13 <= image_in[(r-1)*WIDTH + (c+1)];
                
                p21 <= image_in[r*WIDTH + (c-1)];
                p22 <= image_in[r*WIDTH + c];
                p23 <= image_in[r*WIDTH + (c+1)];
                
                p31 <= image_in[(r+1)*WIDTH + (c-1)];
                p32 <= image_in[(r+1)*WIDTH + c];
                p33 <= image_in[(r+1)*WIDTH + (c+1)];

                // Wait one cycle for the pipelined math to compute
                @(posedge clk); 
                
                // Write the resulting pixel to the output file
                $fwrite(file_out, "%02x\n", pixel_out);
            end
        end

        // 3. Close file and finish simulation
        $fclose(file_out);
        $display("Simulation Complete.");
        $finish;
    end

endmodule